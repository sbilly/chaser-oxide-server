// Copyright 2026 Chaser-Oxide Server
// Element interaction service

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.2
// source: element.proto

package protos

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ElementService_FindElement_FullMethodName    = "/chaser.oxide.v1.ElementService/FindElement"
	ElementService_FindElements_FullMethodName   = "/chaser.oxide.v1.ElementService/FindElements"
	ElementService_Click_FullMethodName          = "/chaser.oxide.v1.ElementService/Click"
	ElementService_Type_FullMethodName           = "/chaser.oxide.v1.ElementService/Type"
	ElementService_Fill_FullMethodName           = "/chaser.oxide.v1.ElementService/Fill"
	ElementService_GetAttribute_FullMethodName   = "/chaser.oxide.v1.ElementService/GetAttribute"
	ElementService_GetAttributes_FullMethodName  = "/chaser.oxide.v1.ElementService/GetAttributes"
	ElementService_GetText_FullMethodName        = "/chaser.oxide.v1.ElementService/GetText"
	ElementService_GetHTML_FullMethodName        = "/chaser.oxide.v1.ElementService/GetHTML"
	ElementService_Hover_FullMethodName          = "/chaser.oxide.v1.ElementService/Hover"
	ElementService_Focus_FullMethodName          = "/chaser.oxide.v1.ElementService/Focus"
	ElementService_SelectOption_FullMethodName   = "/chaser.oxide.v1.ElementService/SelectOption"
	ElementService_UploadFile_FullMethodName     = "/chaser.oxide.v1.ElementService/UploadFile"
	ElementService_ScrollIntoView_FullMethodName = "/chaser.oxide.v1.ElementService/ScrollIntoView"
	ElementService_GetBoundingBox_FullMethodName = "/chaser.oxide.v1.ElementService/GetBoundingBox"
	ElementService_IsVisible_FullMethodName      = "/chaser.oxide.v1.ElementService/IsVisible"
	ElementService_IsEnabled_FullMethodName      = "/chaser.oxide.v1.ElementService/IsEnabled"
	ElementService_WaitForElement_FullMethodName = "/chaser.oxide.v1.ElementService/WaitForElement"
	ElementService_GetProperties_FullMethodName  = "/chaser.oxide.v1.ElementService/GetProperties"
	ElementService_PressKey_FullMethodName       = "/chaser.oxide.v1.ElementService/PressKey"
	ElementService_DragAndDrop_FullMethodName    = "/chaser.oxide.v1.ElementService/DragAndDrop"
)

// ElementServiceClient is the client API for ElementService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ============= ElementService =============
// Handles DOM element finding and interaction
type ElementServiceClient interface {
	// Find a single element
	FindElement(ctx context.Context, in *FindElementRequest, opts ...grpc.CallOption) (*FindElementResponse, error)
	// Find multiple elements
	FindElements(ctx context.Context, in *FindElementsRequest, opts ...grpc.CallOption) (*FindElementsResponse, error)
	// Click on an element
	Click(ctx context.Context, in *ClickRequest, opts ...grpc.CallOption) (*ClickResponse, error)
	// Type text into an element
	Type(ctx context.Context, in *TypeRequest, opts ...grpc.CallOption) (*TypeResponse, error)
	// Fill a form element
	Fill(ctx context.Context, in *FillRequest, opts ...grpc.CallOption) (*FillResponse, error)
	// Get element attribute
	GetAttribute(ctx context.Context, in *GetAttributeRequest, opts ...grpc.CallOption) (*GetAttributeResponse, error)
	// Get multiple attributes
	GetAttributes(ctx context.Context, in *GetAttributesRequest, opts ...grpc.CallOption) (*GetAttributesResponse, error)
	// Get element text content
	GetText(ctx context.Context, in *GetTextRequest, opts ...grpc.CallOption) (*GetTextResponse, error)
	// Get inner HTML
	GetHTML(ctx context.Context, in *GetHTMLRequest, opts ...grpc.CallOption) (*GetHTMLResponse, error)
	// Hover over an element
	Hover(ctx context.Context, in *HoverRequest, opts ...grpc.CallOption) (*HoverResponse, error)
	// Focus on an element
	Focus(ctx context.Context, in *FocusRequest, opts ...grpc.CallOption) (*FocusResponse, error)
	// Select option(s) from a dropdown
	SelectOption(ctx context.Context, in *SelectOptionRequest, opts ...grpc.CallOption) (*SelectOptionResponse, error)
	// Upload file
	UploadFile(ctx context.Context, in *UploadFileRequest, opts ...grpc.CallOption) (*UploadFileResponse, error)
	// Scroll element into view
	ScrollIntoView(ctx context.Context, in *ScrollIntoViewRequest, opts ...grpc.CallOption) (*ScrollIntoViewResponse, error)
	// Get element bounding box
	GetBoundingBox(ctx context.Context, in *GetBoundingBoxRequest, opts ...grpc.CallOption) (*GetBoundingBoxResponse, error)
	// Check if element is visible
	IsVisible(ctx context.Context, in *IsVisibleRequest, opts ...grpc.CallOption) (*IsVisibleResponse, error)
	// Check if element is enabled
	IsEnabled(ctx context.Context, in *IsEnabledRequest, opts ...grpc.CallOption) (*IsEnabledResponse, error)
	// Wait for element
	WaitForElement(ctx context.Context, in *WaitForElementRequest, opts ...grpc.CallOption) (*WaitForElementResponse, error)
	// Get element properties
	GetProperties(ctx context.Context, in *GetPropertiesRequest, opts ...grpc.CallOption) (*GetPropertiesResponse, error)
	// Press key on element
	PressKey(ctx context.Context, in *PressKeyRequest, opts ...grpc.CallOption) (*PressKeyResponse, error)
	// Drag and drop
	DragAndDrop(ctx context.Context, in *DragAndDropRequest, opts ...grpc.CallOption) (*DragAndDropResponse, error)
}

type elementServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewElementServiceClient(cc grpc.ClientConnInterface) ElementServiceClient {
	return &elementServiceClient{cc}
}

func (c *elementServiceClient) FindElement(ctx context.Context, in *FindElementRequest, opts ...grpc.CallOption) (*FindElementResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindElementResponse)
	err := c.cc.Invoke(ctx, ElementService_FindElement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elementServiceClient) FindElements(ctx context.Context, in *FindElementsRequest, opts ...grpc.CallOption) (*FindElementsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindElementsResponse)
	err := c.cc.Invoke(ctx, ElementService_FindElements_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elementServiceClient) Click(ctx context.Context, in *ClickRequest, opts ...grpc.CallOption) (*ClickResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClickResponse)
	err := c.cc.Invoke(ctx, ElementService_Click_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elementServiceClient) Type(ctx context.Context, in *TypeRequest, opts ...grpc.CallOption) (*TypeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TypeResponse)
	err := c.cc.Invoke(ctx, ElementService_Type_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elementServiceClient) Fill(ctx context.Context, in *FillRequest, opts ...grpc.CallOption) (*FillResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FillResponse)
	err := c.cc.Invoke(ctx, ElementService_Fill_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elementServiceClient) GetAttribute(ctx context.Context, in *GetAttributeRequest, opts ...grpc.CallOption) (*GetAttributeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAttributeResponse)
	err := c.cc.Invoke(ctx, ElementService_GetAttribute_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elementServiceClient) GetAttributes(ctx context.Context, in *GetAttributesRequest, opts ...grpc.CallOption) (*GetAttributesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAttributesResponse)
	err := c.cc.Invoke(ctx, ElementService_GetAttributes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elementServiceClient) GetText(ctx context.Context, in *GetTextRequest, opts ...grpc.CallOption) (*GetTextResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTextResponse)
	err := c.cc.Invoke(ctx, ElementService_GetText_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elementServiceClient) GetHTML(ctx context.Context, in *GetHTMLRequest, opts ...grpc.CallOption) (*GetHTMLResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetHTMLResponse)
	err := c.cc.Invoke(ctx, ElementService_GetHTML_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elementServiceClient) Hover(ctx context.Context, in *HoverRequest, opts ...grpc.CallOption) (*HoverResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HoverResponse)
	err := c.cc.Invoke(ctx, ElementService_Hover_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elementServiceClient) Focus(ctx context.Context, in *FocusRequest, opts ...grpc.CallOption) (*FocusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FocusResponse)
	err := c.cc.Invoke(ctx, ElementService_Focus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elementServiceClient) SelectOption(ctx context.Context, in *SelectOptionRequest, opts ...grpc.CallOption) (*SelectOptionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SelectOptionResponse)
	err := c.cc.Invoke(ctx, ElementService_SelectOption_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elementServiceClient) UploadFile(ctx context.Context, in *UploadFileRequest, opts ...grpc.CallOption) (*UploadFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadFileResponse)
	err := c.cc.Invoke(ctx, ElementService_UploadFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elementServiceClient) ScrollIntoView(ctx context.Context, in *ScrollIntoViewRequest, opts ...grpc.CallOption) (*ScrollIntoViewResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScrollIntoViewResponse)
	err := c.cc.Invoke(ctx, ElementService_ScrollIntoView_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elementServiceClient) GetBoundingBox(ctx context.Context, in *GetBoundingBoxRequest, opts ...grpc.CallOption) (*GetBoundingBoxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBoundingBoxResponse)
	err := c.cc.Invoke(ctx, ElementService_GetBoundingBox_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elementServiceClient) IsVisible(ctx context.Context, in *IsVisibleRequest, opts ...grpc.CallOption) (*IsVisibleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsVisibleResponse)
	err := c.cc.Invoke(ctx, ElementService_IsVisible_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elementServiceClient) IsEnabled(ctx context.Context, in *IsEnabledRequest, opts ...grpc.CallOption) (*IsEnabledResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsEnabledResponse)
	err := c.cc.Invoke(ctx, ElementService_IsEnabled_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elementServiceClient) WaitForElement(ctx context.Context, in *WaitForElementRequest, opts ...grpc.CallOption) (*WaitForElementResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WaitForElementResponse)
	err := c.cc.Invoke(ctx, ElementService_WaitForElement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elementServiceClient) GetProperties(ctx context.Context, in *GetPropertiesRequest, opts ...grpc.CallOption) (*GetPropertiesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPropertiesResponse)
	err := c.cc.Invoke(ctx, ElementService_GetProperties_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elementServiceClient) PressKey(ctx context.Context, in *PressKeyRequest, opts ...grpc.CallOption) (*PressKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PressKeyResponse)
	err := c.cc.Invoke(ctx, ElementService_PressKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *elementServiceClient) DragAndDrop(ctx context.Context, in *DragAndDropRequest, opts ...grpc.CallOption) (*DragAndDropResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DragAndDropResponse)
	err := c.cc.Invoke(ctx, ElementService_DragAndDrop_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ElementServiceServer is the server API for ElementService service.
// All implementations must embed UnimplementedElementServiceServer
// for forward compatibility.
//
// ============= ElementService =============
// Handles DOM element finding and interaction
type ElementServiceServer interface {
	// Find a single element
	FindElement(context.Context, *FindElementRequest) (*FindElementResponse, error)
	// Find multiple elements
	FindElements(context.Context, *FindElementsRequest) (*FindElementsResponse, error)
	// Click on an element
	Click(context.Context, *ClickRequest) (*ClickResponse, error)
	// Type text into an element
	Type(context.Context, *TypeRequest) (*TypeResponse, error)
	// Fill a form element
	Fill(context.Context, *FillRequest) (*FillResponse, error)
	// Get element attribute
	GetAttribute(context.Context, *GetAttributeRequest) (*GetAttributeResponse, error)
	// Get multiple attributes
	GetAttributes(context.Context, *GetAttributesRequest) (*GetAttributesResponse, error)
	// Get element text content
	GetText(context.Context, *GetTextRequest) (*GetTextResponse, error)
	// Get inner HTML
	GetHTML(context.Context, *GetHTMLRequest) (*GetHTMLResponse, error)
	// Hover over an element
	Hover(context.Context, *HoverRequest) (*HoverResponse, error)
	// Focus on an element
	Focus(context.Context, *FocusRequest) (*FocusResponse, error)
	// Select option(s) from a dropdown
	SelectOption(context.Context, *SelectOptionRequest) (*SelectOptionResponse, error)
	// Upload file
	UploadFile(context.Context, *UploadFileRequest) (*UploadFileResponse, error)
	// Scroll element into view
	ScrollIntoView(context.Context, *ScrollIntoViewRequest) (*ScrollIntoViewResponse, error)
	// Get element bounding box
	GetBoundingBox(context.Context, *GetBoundingBoxRequest) (*GetBoundingBoxResponse, error)
	// Check if element is visible
	IsVisible(context.Context, *IsVisibleRequest) (*IsVisibleResponse, error)
	// Check if element is enabled
	IsEnabled(context.Context, *IsEnabledRequest) (*IsEnabledResponse, error)
	// Wait for element
	WaitForElement(context.Context, *WaitForElementRequest) (*WaitForElementResponse, error)
	// Get element properties
	GetProperties(context.Context, *GetPropertiesRequest) (*GetPropertiesResponse, error)
	// Press key on element
	PressKey(context.Context, *PressKeyRequest) (*PressKeyResponse, error)
	// Drag and drop
	DragAndDrop(context.Context, *DragAndDropRequest) (*DragAndDropResponse, error)
	mustEmbedUnimplementedElementServiceServer()
}

// UnimplementedElementServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedElementServiceServer struct{}

func (UnimplementedElementServiceServer) FindElement(context.Context, *FindElementRequest) (*FindElementResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FindElement not implemented")
}
func (UnimplementedElementServiceServer) FindElements(context.Context, *FindElementsRequest) (*FindElementsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FindElements not implemented")
}
func (UnimplementedElementServiceServer) Click(context.Context, *ClickRequest) (*ClickResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Click not implemented")
}
func (UnimplementedElementServiceServer) Type(context.Context, *TypeRequest) (*TypeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Type not implemented")
}
func (UnimplementedElementServiceServer) Fill(context.Context, *FillRequest) (*FillResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Fill not implemented")
}
func (UnimplementedElementServiceServer) GetAttribute(context.Context, *GetAttributeRequest) (*GetAttributeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAttribute not implemented")
}
func (UnimplementedElementServiceServer) GetAttributes(context.Context, *GetAttributesRequest) (*GetAttributesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAttributes not implemented")
}
func (UnimplementedElementServiceServer) GetText(context.Context, *GetTextRequest) (*GetTextResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetText not implemented")
}
func (UnimplementedElementServiceServer) GetHTML(context.Context, *GetHTMLRequest) (*GetHTMLResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetHTML not implemented")
}
func (UnimplementedElementServiceServer) Hover(context.Context, *HoverRequest) (*HoverResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Hover not implemented")
}
func (UnimplementedElementServiceServer) Focus(context.Context, *FocusRequest) (*FocusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Focus not implemented")
}
func (UnimplementedElementServiceServer) SelectOption(context.Context, *SelectOptionRequest) (*SelectOptionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SelectOption not implemented")
}
func (UnimplementedElementServiceServer) UploadFile(context.Context, *UploadFileRequest) (*UploadFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UploadFile not implemented")
}
func (UnimplementedElementServiceServer) ScrollIntoView(context.Context, *ScrollIntoViewRequest) (*ScrollIntoViewResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ScrollIntoView not implemented")
}
func (UnimplementedElementServiceServer) GetBoundingBox(context.Context, *GetBoundingBoxRequest) (*GetBoundingBoxResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBoundingBox not implemented")
}
func (UnimplementedElementServiceServer) IsVisible(context.Context, *IsVisibleRequest) (*IsVisibleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IsVisible not implemented")
}
func (UnimplementedElementServiceServer) IsEnabled(context.Context, *IsEnabledRequest) (*IsEnabledResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IsEnabled not implemented")
}
func (UnimplementedElementServiceServer) WaitForElement(context.Context, *WaitForElementRequest) (*WaitForElementResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WaitForElement not implemented")
}
func (UnimplementedElementServiceServer) GetProperties(context.Context, *GetPropertiesRequest) (*GetPropertiesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetProperties not implemented")
}
func (UnimplementedElementServiceServer) PressKey(context.Context, *PressKeyRequest) (*PressKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PressKey not implemented")
}
func (UnimplementedElementServiceServer) DragAndDrop(context.Context, *DragAndDropRequest) (*DragAndDropResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DragAndDrop not implemented")
}
func (UnimplementedElementServiceServer) mustEmbedUnimplementedElementServiceServer() {}
func (UnimplementedElementServiceServer) testEmbeddedByValue()                        {}

// UnsafeElementServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ElementServiceServer will
// result in compilation errors.
type UnsafeElementServiceServer interface {
	mustEmbedUnimplementedElementServiceServer()
}

func RegisterElementServiceServer(s grpc.ServiceRegistrar, srv ElementServiceServer) {
	// If the following call panics, it indicates UnimplementedElementServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ElementService_ServiceDesc, srv)
}

func _ElementService_FindElement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindElementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElementServiceServer).FindElement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ElementService_FindElement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElementServiceServer).FindElement(ctx, req.(*FindElementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElementService_FindElements_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindElementsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElementServiceServer).FindElements(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ElementService_FindElements_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElementServiceServer).FindElements(ctx, req.(*FindElementsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElementService_Click_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClickRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElementServiceServer).Click(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ElementService_Click_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElementServiceServer).Click(ctx, req.(*ClickRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElementService_Type_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElementServiceServer).Type(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ElementService_Type_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElementServiceServer).Type(ctx, req.(*TypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElementService_Fill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FillRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElementServiceServer).Fill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ElementService_Fill_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElementServiceServer).Fill(ctx, req.(*FillRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElementService_GetAttribute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAttributeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElementServiceServer).GetAttribute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ElementService_GetAttribute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElementServiceServer).GetAttribute(ctx, req.(*GetAttributeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElementService_GetAttributes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAttributesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElementServiceServer).GetAttributes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ElementService_GetAttributes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElementServiceServer).GetAttributes(ctx, req.(*GetAttributesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElementService_GetText_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElementServiceServer).GetText(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ElementService_GetText_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElementServiceServer).GetText(ctx, req.(*GetTextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElementService_GetHTML_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHTMLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElementServiceServer).GetHTML(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ElementService_GetHTML_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElementServiceServer).GetHTML(ctx, req.(*GetHTMLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElementService_Hover_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HoverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElementServiceServer).Hover(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ElementService_Hover_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElementServiceServer).Hover(ctx, req.(*HoverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElementService_Focus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FocusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElementServiceServer).Focus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ElementService_Focus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElementServiceServer).Focus(ctx, req.(*FocusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElementService_SelectOption_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SelectOptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElementServiceServer).SelectOption(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ElementService_SelectOption_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElementServiceServer).SelectOption(ctx, req.(*SelectOptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElementService_UploadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElementServiceServer).UploadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ElementService_UploadFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElementServiceServer).UploadFile(ctx, req.(*UploadFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElementService_ScrollIntoView_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScrollIntoViewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElementServiceServer).ScrollIntoView(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ElementService_ScrollIntoView_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElementServiceServer).ScrollIntoView(ctx, req.(*ScrollIntoViewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElementService_GetBoundingBox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBoundingBoxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElementServiceServer).GetBoundingBox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ElementService_GetBoundingBox_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElementServiceServer).GetBoundingBox(ctx, req.(*GetBoundingBoxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElementService_IsVisible_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsVisibleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElementServiceServer).IsVisible(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ElementService_IsVisible_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElementServiceServer).IsVisible(ctx, req.(*IsVisibleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElementService_IsEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsEnabledRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElementServiceServer).IsEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ElementService_IsEnabled_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElementServiceServer).IsEnabled(ctx, req.(*IsEnabledRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElementService_WaitForElement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WaitForElementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElementServiceServer).WaitForElement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ElementService_WaitForElement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElementServiceServer).WaitForElement(ctx, req.(*WaitForElementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElementService_GetProperties_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPropertiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElementServiceServer).GetProperties(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ElementService_GetProperties_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElementServiceServer).GetProperties(ctx, req.(*GetPropertiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElementService_PressKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PressKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElementServiceServer).PressKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ElementService_PressKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElementServiceServer).PressKey(ctx, req.(*PressKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ElementService_DragAndDrop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DragAndDropRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ElementServiceServer).DragAndDrop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ElementService_DragAndDrop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ElementServiceServer).DragAndDrop(ctx, req.(*DragAndDropRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ElementService_ServiceDesc is the grpc.ServiceDesc for ElementService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ElementService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chaser.oxide.v1.ElementService",
	HandlerType: (*ElementServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FindElement",
			Handler:    _ElementService_FindElement_Handler,
		},
		{
			MethodName: "FindElements",
			Handler:    _ElementService_FindElements_Handler,
		},
		{
			MethodName: "Click",
			Handler:    _ElementService_Click_Handler,
		},
		{
			MethodName: "Type",
			Handler:    _ElementService_Type_Handler,
		},
		{
			MethodName: "Fill",
			Handler:    _ElementService_Fill_Handler,
		},
		{
			MethodName: "GetAttribute",
			Handler:    _ElementService_GetAttribute_Handler,
		},
		{
			MethodName: "GetAttributes",
			Handler:    _ElementService_GetAttributes_Handler,
		},
		{
			MethodName: "GetText",
			Handler:    _ElementService_GetText_Handler,
		},
		{
			MethodName: "GetHTML",
			Handler:    _ElementService_GetHTML_Handler,
		},
		{
			MethodName: "Hover",
			Handler:    _ElementService_Hover_Handler,
		},
		{
			MethodName: "Focus",
			Handler:    _ElementService_Focus_Handler,
		},
		{
			MethodName: "SelectOption",
			Handler:    _ElementService_SelectOption_Handler,
		},
		{
			MethodName: "UploadFile",
			Handler:    _ElementService_UploadFile_Handler,
		},
		{
			MethodName: "ScrollIntoView",
			Handler:    _ElementService_ScrollIntoView_Handler,
		},
		{
			MethodName: "GetBoundingBox",
			Handler:    _ElementService_GetBoundingBox_Handler,
		},
		{
			MethodName: "IsVisible",
			Handler:    _ElementService_IsVisible_Handler,
		},
		{
			MethodName: "IsEnabled",
			Handler:    _ElementService_IsEnabled_Handler,
		},
		{
			MethodName: "WaitForElement",
			Handler:    _ElementService_WaitForElement_Handler,
		},
		{
			MethodName: "GetProperties",
			Handler:    _ElementService_GetProperties_Handler,
		},
		{
			MethodName: "PressKey",
			Handler:    _ElementService_PressKey_Handler,
		},
		{
			MethodName: "DragAndDrop",
			Handler:    _ElementService_DragAndDrop_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "element.proto",
}
